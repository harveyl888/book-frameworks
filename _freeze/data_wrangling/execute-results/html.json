{
  "hash": "f912e36fc6952eb813fee19b80128048",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Wrangling\n\n## Introduction\n\nOnce imported, one or more data wrangling steps are often required to manipulate data into its required form and format.  This chapter illustrates how data wrangling can be performed using a instruction file using the {dplyr} library.  Of course, other approaches, such as using base R functions and {data.table} may also be applied and the concepts presented here will hold true.\n\n## Non-Standard Evaluation\n\n## Command Parsing {#sec-command-parsing}\n\nThe simplest approach is to specify the data manipulation step and execute it by evaluating it as an expression.  The base R functions `eval` and `parse` or the {rlang} function `parse_expr` can be used for this purpose.  There are two cases illustrated below.  The first parses raw R code directly and the second parses a dplyr::filter() step.\n\n### Parsing of R Code\n\nIn the example code below we define a `data_processing` step and evaluate it by parsing.\n\n```json\n{\n  \"data_processing\": \"dplyr::filter(mtcars, mpg > 30)\"\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell filename='base R eval and parse'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- eval(parse(text = inp$data_processing))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n::: {.cell filename='rlang parse_expr'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- rlang::eval_tidy(rlang::parse_expr(inp$data_processing))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Parsing a dplyr::filter() Step\n\nIn the example code below we define `filter_process`, a filter, as `mpg > 30` and evaluate it within a `dplyr::filter()` function.\n\n```json\n{\n  \"filter_process\": \"mpg > 30\"\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell filename='base R eval and parse'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::filter(mtcars, eval(parse(text = inp$filter_process)))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n::: {.cell filename='rlang parse_expr'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::filter(mtcars, !!rlang::parse_expr(inp$filter_process))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nNote that when using the dplyr::filter() function we can take advantage of the `!!` operator and use injection to evaluate it.\n\n:::{.callout-warning}\n## Important\nSuch approaches are simplistic to build but open to abuse.  Parsing raw commands through an interpreter can often lead to undesired effects and should be avoided where possible.  An alternative approach is to break down the data wrangling steps \n:::\n\n## Filter Step\n\nA filter step can be broken down into its integral parts.  When considering filtering a data frame, a filter step consists of the name of the column to apply the filter to, the filter operator, and the filter condition.  When building a filter step for a framework approach we can use this logic to separate the components and recombine in the interpreter.  This enables us to have more control over the filter step itself (for example, it is simpler to include data validation), as well as having control over expression evaluation.\n\n### Filtering on a Single Value with a Named Operator\n\nAs a simple example, we will filter mtcars for values where mpg>30.  Here we define three parameters: `col`, the name of the column we wish to filter, `operator`, the comparison operator and `value`, the condition.  \nIn the first example below an expression is built using the {glue} package and then evaluated using `rlang::parse_expr()`.\n\n```json\n{\n  \"col\": \"mpg\",\n  \"operator\": \">\",\n  \"value\": 30\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell filename='rlang parse_expr'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nfilter_expr <- glue::glue(\"{inp$col} {inp$operator} {inp$value}\")\ndata <- dplyr::filter(mtcars, !!rlang::parse_expr(filter_expr))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe advantage of this method over the ones illustrated in @sec-command-parsing is that individual parameters can be checked for consistency prior to running the evaluation.  For example, we could update our interpreter as follows:\n\n\n\n\n\n\n\n\n::: {.cell filename='rlang parse_expr'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nif (!inp$col %in% colnames(mtcars)) {\n  stop(\"inconsistent column name\")\n}\nif (!inp$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n  stop(\"unknown operator\")\n}\nif (!is.numeric(inp$value)) {\n  stop(\"value is not numeric\")\n}\nfilter_expr <- glue::glue(\"{inp$col} {inp$operator} {inp$value}\")\ndata <- dplyr::filter(mtcars, !!rlang::parse_expr(filter_expr))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIn this case, execution will stop if the json input attempts to filter on an unknown column, use an unknown operator or attempts to filter a value that is non-numeric, as demonstrated below:\n\n```json\n{\n  \"col\": \"new_col_name\",\n  \"operator\": \">\",\n  \"value\": 30\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Error: inconsistent column name\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Operator as an Expression\n\nIn R, operators, such as `==`, `>`, `<`, etc are functions.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`==`(3,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n`==`(4,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAs a more programmatic approach, `match.fun()` or `call` may be used:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noperator <- \"==\"\nmatch.fun(operator)(3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncall(operator, 3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3 == 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe filter step can be rewritten using the operator as a function.  The json file remains as follows:\n\n```json\n{\n  \"col\": \"mpg\",\n  \"operator\": \">\",\n  \"value\": 30\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\nand the interpreter becomes:\n\n\n\n\n\n\n\n\n::: {.cell filename='match.fun'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::filter(mtcars, match.fun(inp$operator)(!!rlang::sym(inp$col), inp$value))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n::: {.cell filename='call'}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::filter(mtcars, !!call(inp$operator, rlang::sym(inp$col), inp$value))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Filtering against a List of Values\n\nOnce the logic for filtering against a single value has been determined it is simple to change it to work for multiple values.  In the example below the value has been replaced by an array of values and the operator is called `in`.\n\n\n```json\n{\n  \"col\": \"cyl\",\n  \"operator\": \"in\",\n  \"value\": [4, 5, 6]\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nfilter_expr <- glue::glue(\"{inp$col} %in% c({glue::glue_collapse(inp$value, sep=',')})\")\ndata <- dplyr::filter(mtcars, !!rlang::parse_expr(filter_expr))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAlternatively, the expression can be built without using {glue}, using `%in%` directly:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::filter(mtcars, !!rlang::sym(inp$col) %in% unlist(inp$value))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Generic Case - Catering for Different Operators\n\nUp to now we've worked against a single type of known operator but the approach can be extended to work against any type of operator.  The interpreter below will work with common logical operators as well as the operator that we have defined as `in`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nif (inp$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n  data <- dplyr::filter(mtcars, match.fun(inp$operator)(!!rlang::sym(inp$col), inp$value))\n} else if (inp$operator == \"in\") {\n  data <- dplyr::filter(mtcars, !!rlang::sym(inp$col) %in% unlist(inp$value))\n}\nprint(data)\n```\n:::\n\n\n\n\n\n\n\n\n### Multiple Operators\n\nFilter steps can be combined using `AND` and `OR` logic to build more complex cases.\n\n#### Combining Filters using `AND`\n\n`AND` is a the default behavior when filters are combined.  The first filter is performed followed by the second and subsequent operators.  To demonstrate, we'll add two filter steps as follows:\n\n```json\n{\n  \"filter_steps\" : [\n    {\n      \"col\": \"cyl\",\n      \"operator\": \"in\",\n      \"value\": [4, 5, 6]\n    },\n    {\n      \"col\": \"mpg\",\n      \"operator\": \">\",\n      \"value\": 30\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- mtcars\nfor (step in inp$filter_steps) {\n  if (step$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n    data <- data |> dplyr::filter(match.fun(step$operator)(!!rlang::sym(step$col), step$value))\n  } else if (step$operator == \"in\") {\n    data <- data |> dplyr::filter(!!rlang::sym(step$col) %in% unlist(step$value))\n  }\n}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n#### Combining Filters using `OR`\n\n`OR` is a little more challenging than `AND` since we cannot simply loop through the conditions and add them sequentially.  One way to work with `OR` logic is to build a single expression through concatenating conditions with the `|` operator and evaluating the resulting combination.  To demonstrate, we'll add two filter steps as follows:\n\n```json\n{\n  \"filter_steps\" : [\n    {\n      \"col\": \"cyl\",\n      \"operator\": \"in\",\n      \"value\": [4, 5, 6]\n    },\n    {\n      \"col\": \"mpg\",\n      \"operator\": \">\",\n      \"value\": 30\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nfilter_expr <- lapply(inp$filter_steps, function(step) {\n  if (step$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n    glue::glue(\"{step$col}{step$operator}{step$value}\")\n  } else if (step$operator == \"in\") {\n    glue::glue(\"{step$col} %in% c({glue::glue_collapse(step$value, sep=',')})\")\n  }\n}) |> glue::glue_collapse(sep = \" | \")\ndata <- dplyr::filter(mtcars, !!rlang::parse_expr(filter_expr))\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### The Challenge of Values and Column Names\n\nIt is important to note the difference between filtering against a value vs. filtering against another column.  For example, in R each of the following are valid:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(mtcars, wt > drat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::filter(mtcars, wt > 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nHowever, when we use an interpreter to parse code built from an instruction file we might wish to use non-standard evaluation.  Unfortunately we cannot use a single approach for both column names and scalar values as `!!sym(column)` is valid but `!!sum(value)` is not.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- 'wt'\nx2 <- 'drat'\ndplyr::filter(mtcars, !!rlang::sym(x1) > !!rlang::sym(x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n```\n\n\n:::\n\n```{.r .cell-code}\nx1 <- 'wt'\nx2 <- 4\n# dplyr::filter(mtcars, !!rlang::sym(x1) > !!rlang::sym(x2))\n# Error in `rlang::sym()`:\n# ! Can't convert a double vector to a symbol.\ndplyr::filter(mtcars, !!rlang::sym(x1) > x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nA solution is to check if `value` is a column name and respond accordingly.  A simple example is shown below.  Bear in mind that the logic may need to be a little more complex than shown here.\n\n```json\n{\n  \"filter_steps\" : [\n    {\n      \"col\": \"cyl\",\n      \"operator\": \">\",\n      \"value\": \"drat\"\n    },\n    {\n      \"col\": \"wt\",\n      \"operator\": \">\",\n      \"value\": 4\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- mtcars\nfor (step in inp$filter_steps) {\n  if (step$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n    if (step$value %in% names(data)) {\n      ## value is the name of a column\n      data <- data |> dplyr::filter(match.fun(step$operator)(!!rlang::sym(step$col), !!rlang::sym(step$value)))\n    } else {\n      ## value is not the name of a column\n      data <- data |> dplyr::filter(match.fun(step$operator)(!!rlang::sym(step$col), step$value))\n    }\n  } else if (step$operator == \"in\") {\n    data <- data |> dplyr::filter(!!rlang::sym(step$col) %in% unlist(step$value))\n  }\n}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Combining Data Import with a Filter Data Step\n\nOur interpreter can be expanded to import and process data.  Using concepts from @sec-importing-data, Our instruction file and interpreter can be extended as follows:\n\n```json\n{\n  \"dataset\": \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-18/chocolate.csv\",\n  \"columns\": [\"ref\", \"cocoa_percent\", \"rating\"],\n  \"filter_step:\" {\n    \"col\": \"cocoa_percent\",\n    \"operator\": \">\",\n    \"value\": 85\n  }\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nonly_cols <- unlist(inp$columns)\nif (isTRUE(tools::file_ext(inp$dataset) == \"csv\")) {\n  data <- readr::read_csv(inp$dataset, col_select = only_cols)\n} else if (isTRUE(tools::file_ext(inp$dataset) == \"sas\")) {\n  data <- haven::read_sas(inp$dataset, col_select = only_cols)\n} else {\n  data <- NULL\n}\nif (!is.null(inp$filter_step)) {\n  if (inp$filter_step$operator %in% c(\"==\", \">\", \"<\", \">=\", \"<=\", \"!=\")) {\n    data <- data |> dplyr::filter(match.fun(inp$filter_step$operator)(!!rlang::sym(inp$filter_step$col), inp$filter_step$value))\n  } else if (inp$filter_step$operator == \"in\") {\n    data <- data |> dplyr::filter(!!rlang::sym(inp$filter_step$col) %in% unlist(inp$filter_step$value))\n  }\n}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 66 × 3\n     ref cocoa_percent rating\n   <dbl> <chr>          <dbl>\n 1   705 88%             3.5 \n 2   464 85%             2.75\n 3   464 85%             3   \n 4   572 85%             2.75\n 5  1788 90%             2.75\n 6   636 88%             3   \n 7  1486 86%             3.25\n 8  1129 85%             3.5 \n 9   259 91%             1.5 \n10  1772 90%             2.5 \n# ℹ 56 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n## Mutate Step\n\nBuilding a mutate step is slightly different to a filter step and requires use of `:=` in place of `=`.  For example, in order to mimic the mutate step `dplyr::mutate(mtcars, my_new_column = 3)` we could use an instruction set and interpreter as follows:\n\n```json\n{\n  \"new_col_name\": \"X\",\n  \"value\": 3\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::mutate(mtcars, !!inp$new_col_name  := inp$value)\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb X\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 3\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 3\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 3\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 3\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 3\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 3\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 3\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 3\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 3\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 3\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 3\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 3\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 3\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 3\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 3\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 3\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 3\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 3\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 3\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 3\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 3\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 3\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 3\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 3\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 3\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 3\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 3\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 3\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nMutate can also be used with a glue-like syntax to pass column names as parameters.  For example:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\ndata <- dplyr::mutate(mtcars, \"{inp$new_col_name}\"  := inp$value)\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb X\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 3\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 3\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 3\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 3\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 3\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 3\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 3\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 3\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 3\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 3\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 3\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 3\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 3\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 3\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 3\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 3\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 3\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 3\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 3\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 3\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 3\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 3\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 3\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 3\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 3\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 3\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 3\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 3\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nMutate steps can be complex, involving multiple columns and internal functions and it may be tempting to use a `parse()` and `eval()` approach.  Caution should be taken however as mutate is more prone to abuse than filter.  Whereas filter simply returns a reduced representation, mutate will change existing or create new columns.\n\n### Mutate With Existing Columns\n\n...\n\n### Combining Data Import with a Mutate Step\n\n...\n\n## Arrange Step\n\n`dplyr::arrange()` sorts columns in ascending or descending order.  It is a little more challenging to build a generic arrange step for two reasons: \n\n  - All components must be included in a single `arrange()` function call and cannot be built up stepwise, unlike other dplyr functions, such as `filter()`.  In a stepwise manner, the first `arrange()` function call will be discarded for the second, the second for the third and so on.  Only the last `arrange()` function call would be honored.\n  - The use of the `desc()` function must be encoded in the process.  Since the `arrange()` step is not built up stepwise, use of `desc()` becomes a little more challenging.\n\nThe instruction set and interpreter below illustrates how an arrange step, with multiple columns, can be built.\n\n```json\n[\n  {\n    \"column\": \"gear\",\n    \"direction\": \"asc\"\n  },\n  {\n    \"column\": \"cyl\",\n    \"direction\": \"desc\"\n  },\n  {\n    \"column\": \"mpg\"\n  }\n]\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\n\narrange_content <- purrr::map(inp, \\(x) {\n  if (isTRUE(x[['direction']] == \"desc\")) {\n    rlang::call2(\"desc\", rlang::sym(x[['column']]), .ns = \"dplyr\")\n  } else { \n    rlang::sym(x[['column']])\n  }\n})\ndata <- dplyr::arrange(mtcars, !!!arrange_content)\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nSo let's look at what is happening in the code above.  We run `purrr::map()` over each of the arrange parameters.  Inside the `map()` function we check to direction - *ascending* or *descending* with the default being *ascending*.  \nFor *ascending* columns the column name is converted to a symbol and returned.  \nFor *descending* columns, the column name is converted to a symbol and `rlang::call2()` is used to retun a function call to `dplyr::desc()` without executing the call.  \nThe list returned by `purrr::map()` is then injected into `arrange()` using `!!!` which is the list equivalent of `!!`.\n\nThe result of `arrange_content` is:\n\n\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\ngear\n\n[[2]]\ndplyr::desc(cyl)\n\n[[3]]\nmpg\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Combining Data Import with an Arrange Step\n\nUsing concepts from @sec-importing-data, Our instruction file and interpreter can be extended to include an arrange step as follows:\n\n```json\n{\n  \"dataset\": \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-11-30/matches.csv\",\n  \"columns\": [\"match_id\", \"score_team1\", \"score_team2\", \"wickets_team\", \"wickets_team2\"],\n  \"arrange_step:\" [\n    {\n      \"column\": \"wickets_team1\"\n    },\n    {\n      \"column\": \"wickets_team2\"\n    },\n    {\n      \"column\": \"score_team1\",\n      \"direction\": \"desc\"\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\nonly_cols <- unlist(inp$columns)\nif (isTRUE(tools::file_ext(inp$dataset) == \"csv\")) {\n  data <- readr::read_csv(inp$dataset, col_select = only_cols)\n} else if (isTRUE(tools::file_ext(inp$dataset) == \"sas\")) {\n  data <- haven::read_sas(inp$dataset, col_select = only_cols)\n} else {\n  data <- NULL\n}\n\nif (!is.null(inp$arrange_step)) {\n  arrange_content <- purrr::map(inp$arrange_step, \\(x) {\n    if (isTRUE(x[['direction']] == \"desc\")) {\n      rlang::call2(\"desc\", rlang::sym(x[['column']]), .ns = \"dplyr\")\n    } else { \n      rlang::sym(x[['column']])\n    }\n  })\n  data <- dplyr::arrange(data, !!!arrange_content)\n}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,237 × 5\n   match_id   score_team1 score_team2 wickets_team1 wickets_team2\n   <chr>            <dbl>       <dbl>         <dbl>         <dbl>\n 1 ODI # 1943         340         104             2             5\n 2 ODI # 2096         304         310             2             6\n 3 ODI # 1457         329         235             2             7\n 4 ODI # 2061         347         286             2             8\n 5 ODI # 1049         321         152             2             8\n 6 ODI # 1523         376         202             2            10\n 7 ODI # 1993         359         234             2            10\n 8 ODI # 1964         311         130             2            10\n 9 ODI # 1960         170         122             2            10\n10 ODI # 1070         271         272             3             4\n# ℹ 1,227 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}