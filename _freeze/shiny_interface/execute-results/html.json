{
  "hash": "35b7362953d1834eab1f69e40b2c99bd",
  "result": {
    "engine": "knitr",
    "markdown": "# Building a Shiny Interface\n\n## Introduction\n\nIn addition to working with data, a framework can be used to construct an interface in shiny.  The concept is much the same - define the interface through a series of instructions and use an engine to interpret and execute.\n\n## A Minimal Example - Interpreting a Single widget\n\nIt's fairly straightforward to build a shiny widget programatically.  A traditional approach to including a widget, for example a `textInput` control, is:\n\n```r\ntextInput(inputId = \"my_textinput_id\", label = \"my_textinput_label\")\n```\n\nFrom a programatic perspective, we can generate the textInput control using just an id and label.  Our instruction set can be as simple as the following:\n\n```json\n{\n  \"id\": \"my_textinput_id\",\n  \"label\": \"my_textinput_label\"\n}\n```\n\nand the interpreter could be:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\n\nserver <- function(input, output, session) {\n  output$uiout <- renderUI({\n    textInput(inputId = inp$id, label = inp$label)\n  })    \n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\n![](images/shiny_interface_01.png)\n\n## Example - Buidling Multiple Widgets\n\nAs a simple example, let's build a set of textInputs using the approach.  The instruction file would look something like:\n\n```json\n{\n  \"id_prefix\": \"mywidget\",\n  \"widget\": \"textInput\",\n  \"count\": 5\n}\n```\n\nThis file contains three parameters, `widget`, is the type of widget you wish to build, `id_prefix` is a prefix used in defining the id, and `count` is the number of widgets to build.  Our interpreter is fairly simple - read in the file and build a series of inputs.  It looks as follows:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\n\nserver <- function(input, output, session) {\n\n  output$uiout <- renderUI({\n    shiny_out <- lapply(seq(inp$count), function(i) {\n      if (inp$widget == \"textInput\") {\n        textInput(inputId = sprintf(\"%s_%02i\", inp$id_prefix, i), label = sprintf(\"textInput %02i\", i))\n      }\n    })\n\n    fluidRow(\n      tagList(shiny_out)\n    )\n    \n  })\n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\n![](images/shiny_interface_02.png)\n\nTo build the same set in a single row the condition statement can be changed to read as follows:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\n\nserver <- function(input, output, session) {\n\n  output$uiout <- renderUI({\n    col_width <- as.integer(12 / inp$count)\n    shiny_out <- lapply(seq(inp$count), function(i) {\n      if (inp$widget == \"textInput\") {\n        column(\n          textInput(inputId = sprintf(\"%s_%02i\", inp$id_prefix, i), label = sprintf(\"textInput %02i\", i)),\n          width = col_width\n        )\n      }\n    })\n\n    fluidRow(\n      tagList(shiny_out)\n    )\n    \n  })\n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\nwhich leads to the following output:\n\n![](images/shiny_interface_03.png)\n\n## A More Complex Design\n\nWe can extend the approach further by specifying widget details in the instruction file.  This allows finer grain control on the properties of the widgets themselves.  For example, we can build the following instruction set:\n\n```json\n{\n  \"interface\": [\n    {\n      \"type\": \"textInput\",\n      \"label\": \"my textInput\"\n    },\n    {\n      \"type\": \"selectizeInput\",\n      \"label\": \"my selectizeInput\",\n      \"choices\": [\"A\", \"B\", \"C\"]\n    }\n  ]\n}\n\n```\n\nwhich can be interpreted:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\ninp <- jsonlite::fromJSON(\"data/myfile.json\", simplifyVector = FALSE)\n\nserver <- function(input, output, session) {\n  output$uiout <- renderUI({\n    shiny_out <- lapply(seq(length(inp$interface)), function(i) {\n      widget <- inp$interface[[i]]\n      if (widget$type == \"textInput\") {\n        textInput(inputId = sprintf(\"widget_%02i\", i), label = widget$label, value = widget$value)\n      } else if (widget$type == \"selectizeInput\") {\n        selectizeInput(inputId = sprintf(\"widget_%02i\", i), label = widget$label, choices = widget$choices)\n      }\n    })\n\n    fluidRow(\n      tagList(shiny_out)\n    )\n  })\n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\nleading to the following output:\n\n![](images/shiny_interface_04.png)\n\nThere are a few things to unpack in the interpreter.  Firstly, it can accept an unlimited number of widgets and, if the logic is extended, any type.  Secondly, the choices for the selectize have been defined in the instruction set, illustrating how widgets can be built to specification using instruction parameters.  Thirdly, the logic for the textInput widget expects a default value which is not set in our instruction set.  Here we take advantage of the fact that {jsonlite} converts our json instructions into an R list.  Since `value` is missing in our instruction set, it evaluates to `NULL`.  This is the default for the `value` parameter in `textInput` and therefore no `value` is applied.  If it had been set in the instruction set, a value would have been applied to the textInput widget.\n\n## Automatic Assignment of Widgets\n\nShiny has a number of widgets that can be used to input data within a shiny app.  They can be used to build an interface, identifying the most appropriate widget for the data.  For example, working with the `survivalists.csv` Alone data set from Tidy Tuesday:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf  <- \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv\"\ndata <- readr::read_csv(f)\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 94 × 16\n   season name               age gender city    state country result days_lasted\n    <dbl> <chr>            <dbl> <chr>  <chr>   <chr> <chr>    <dbl>       <dbl>\n 1      1 Alan Kay            40 Male   Blairs… Geor… United…      1          56\n 2      1 Sam Larson          22 Male   Lincoln Nebr… United…      2          55\n 3      1 Mitch Mitchell      34 Male   Bellin… Mass… United…      3          43\n 4      1 Lucas Miller        32 Male   Quasqu… Iowa  United…      4          39\n 5      1 Dustin Feher        37 Male   Pittsb… Penn… United…      5           8\n 6      1 Brant McGee         44 Male   Albema… Nort… United…      6           6\n 7      1 Wayne Russell       46 Male   Saint … New … Canada       7           4\n 8      1 Joe Robinet         24 Male   Windsor Onta… Canada       8           4\n 9      1 Chris Weatherman    41 Male   Umatil… Flor… United…      9           1\n10      1 Josh Chavez         31 Male   Jackson Ohio  United…     10           0\n# ℹ 84 more rows\n# ℹ 7 more variables: medically_evacuated <lgl>, reason_tapped_out <chr>,\n#   reason_category <chr>, team <chr>, day_linked_up <dbl>, profession <chr>,\n#   url <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn this case we'll write an instruction set to import a selected set of columns from the data (see @sec-importing-data) and automatically build a set of inputs for each column, based on the data imported.  The instructions are as follows:\n\n```json\n{\n  \"dataset\": \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv\",\n  \"columns\": [\"season\", \"age\", \"gender\", \"country\", \"medically_evacuated\", \"profession\"],\n  \"build_widgets\": true\n}\n```\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nThe interpreter could look something like:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninp <- list(dataset=\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv\", columns=list(\"season\", \"age\", \"gender\", \"country\", \"medically_evacuated\", \"profession\"), build_widgets=TRUE)\n\nonly_cols <- unlist(inp$columns)\ndata <- readr::read_csv(inp$dataset, col_select = only_cols)\n\nlibrary(shiny)\n\nserver <- function(input, output, session) {\n  \n  output$uiout <- renderUI({\n    \n    shiny_out <- lapply(seq(ncol(data)), function(i) {\n      col_class <- sapply(data, class)[i]\n      if (col_class == \"logical\") {\n        ## checkbox\n        checkboxInput(inputId = sprintf(\"Control_%02i\", i), \n                      label = names(data)[i])\n      } else if (col_class == \"numeric\") {\n        ## numericInput\n        if (length(unique(data[[i]])) > 10) {\n          sliderInput(inputId = sprintf(\"Control_%02i\", i),\n                      label = names(data)[i],\n                      min = min(data[[i]]),\n                      max = max(data[[i]]),\n                      value = min(data[[i]]))\n        } else {\n          numericInput(inputId = sprintf(\"Control_%02i\", i), \n                       label = names(data)[i],\n                       min = min(data[[i]]),\n                       max = max(data[[i]]),\n                       value = min(data[[i]]))\n        }\n      } else if (col_class == \"character\") {\n        n_values <- length(unique(data[[i]]))\n        if (n_values <= 3) {\n          ## radiobuttons\n          radioButtons(inputId = sprintf(\"Control_%02i\", i),\n                       label = names(data)[i],\n                       inline = TRUE,\n                       choices = sort(unique(data[[i]])))\n        } else {\n          ## selectizeInput\n          selectizeInput(inputId = sprintf(\"Control_%02i\", i),\n                         label = names(data)[i],\n                         choices = sort(unique(data[[i]])))\n        }\n      } \n    })\n    tagList(shiny_out)\n  })\n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\nIn the logic above the following applies:\n\n-  If a column contain logical data, render as a checkbox.\n-  If a column is numeric with more than 10 values, render as a sliderInput.\n-  If a column is numeric with 10 or less values, render as a numericInput.\n-  If a column is character with 3 or less values, render as radioButtons.\n-  If a column is character with more than 10 values, render as a selectizeInput.\n\n![](images/shiny_interface_05.png)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}