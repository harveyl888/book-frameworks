{
  "hash": "0b9e94f8ace1d2b5a1358af8102a0756",
  "result": {
    "engine": "knitr",
    "markdown": "# Automating Shiny Reactivity\n\nA minimal amount of shiny reactivity can be introduced in an automated fashion.  For extensive shiny reactivity the author is encouraged to consider shiny modules, covered in a later chapter.\n\n## Adding Reactivity - Multiple observeEvents\n\nIn this example, we'll build a series of actionButtons and assign a shiny observe/bindEvent function to each.  The observe function responds to a button press, updating a reactiveValue.  It's important to note that in the code below we generate five observe functions programatically.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n  \n  rv <- reactiveValues(\n    click = \"\"\n  )\n  \n  output$uiout <- renderUI({\n    lapply(seq(5), function(i) {\n      observe({\n        rv$click <- paste0(\"Button \", i, \" clicked\")\n      }) |>\n        bindEvent(input[[paste0(\"but_\", i)]], ignoreInit = TRUE)\n    })\n    \n    tagList(\n      lapply(seq(5), function(i) {\n        actionButton(inputId = paste0(\"but_\", i), label = paste0(\"Button \", i))\n      })\n    )\n  })\n  \n  output$txt <- renderPrint(\n    print(rv$click)\n  )\n  \n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n  verbatimTextOutput(\"txt\")\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\nThe resulting app contains five actionButtons, each linked to an observeEvent.\n\n![](images/shiny_reactivity_01.png)\n\nThe reactive graph illustrates the five observeEvent functions created programatically.\n\n![](images/shiny_reactivity_02.png)\n\nAlthough effective, this is not a very efficient way of programming.  The next section will ilustrate how to achieve the same effect with a single observe/bindEvent function.\n\n## Adding Reactivity - Single observeEvent\n\nIn this example, we'll build the same series of actionButtons but this time assign a single shiny observe function to all of them.  As before, the observe/bindEvent responds to a button press, updating a reactiveValue.  Here we use the `Shiny.setInputValue` javascript function to set the value of a shiny input variable.  The addition of `{priority: \"event\"}` will ensure that the shiny variable is updated on every button click, even if the same button is clicked two times in succession.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n  \n  rv <- reactiveValues(\n    click = \"\"\n  )\n  \n  output$uiout <- renderUI({\n    \n    observe({\n      rv$click <- paste0(\"Button \", input$button_click, \" clicked\")\n    }) |>\n      bindEvent(input$button_click, ignoreInit = TRUE)\n    \n    tagList(\n      lapply(seq(5), function(i) {\n        actionButton(inputId = paste0(\"but_\", i),\n                     label = paste0(\"Button \", i),\n                     onclick=paste0('Shiny.setInputValue(\"button_click\", ', i, ', {priority: \"event\"})'))\n      })\n    )\n  })\n  \n  output$txt <- renderPrint(\n    print(rv$click)\n  )\n  \n}\n\nui <- fluidPage(\n  uiOutput('uiout')\n  verbatimTextOutput(\"txt\")\n)\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n\n\n\nThe resulting app contains five actionButtons, each linked to an observeEvent.\n\n![](images/shiny_reactivity_03.png)\n\nThe reactive graph illustrates the simpler reactivity.\n\n![](images/shiny_reactivity_04.png)\n\nHere, it should be noted, that we have added an onclick event to each actionButton to trigger an observeEvent.  When an actionButton is clicked the shiny reactive `input$button_click` is updated to the index of the button. \n\n## Applied Using an Instruction set\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}