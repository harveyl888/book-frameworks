# Advanced Instructions

Both JSON and YAML are suitable formats for passing instructions to an engine but each have their limitations.  This section describes how the engine itself can be used to extend the scope of JSON and YAML.  Concepts of variables, loops, etc will be discussed for both JSON and YAML, and demonstrated for JSON, although the same concepts apply to YAML.

## Variables

### Variables in Pure JSON and YAML

JSON does not have a concept of variables or variable reuse.  YAML does include anchors (&) and aliases (*) which allow for reuse.  For example, in YAML the following is permitted:

```yaml
threshold: &thresh 30

filters:
  - col: mpg
    operator: ">"
    value: *thresh
```

`&thresh` defines an anchor and `*thresh` reuses that value.  There are limitations to how anchors and aliases are used.  They are pure substitution, not symbolic evaluation, meaning that the following is not valid:

```yaml
threshold: &thresh 30
max_threshold: *thresh + 10
```

### Building a Variable Parser

#### Simple Case {#sec-variable-simple}

To encode variables in JSON format, consider the following:

```json
{
    "variables": {
        "myVar1": 1,
        "myVar2": "Hello"
    }
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(variables=list(myVar1=1, myVar2="Hello")), 'data/myfile.json', auto_unbox = TRUE)
```

When imported into R, this JSON file appears as:

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
inp
```

The variables listed under `variables` in the JSON file are available through inp$variables$name where `name` is the name of a variable.

Now all we need is a method to replace a variable name with the value of the variable.  This can be achieved by defining a syntax for variables.  For example, in the case below we define variable use as `$name$` where `name` is the name of a variable.  Here `subValue` is set to be equal to the variable `myVar2` by defining it as `$myVar2$`.

```json
{
    "variables": {
        "myVar1": "Hello",
        "myVar2": "World"
    },
    "subValue": "$myVar1$"
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(variables=list(myVar1="Hello", myVar2="World"), subValue="$myVar1$"), 'data/myfile.json', auto_unbox = TRUE)
```

Finally, the engine requires a method to replace variables in the JSON prior to the JSON contents being interpreted and processed.

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
if (!is.null(inp$variables)) {
  for (v in names(inp$variables)) {
    var_name <- paste0("$", v, "$")
    var_value <- inp$variables[[v]]
    inp$subValue <- gsub(var_name, var_value, inp$subValue, fixed = TRUE)
  }
}
print(inp)
```

Since we are simply replacing text with values, variables can be placed as needed.  For example:


```json
{
    "variables": {
        "myVar1": "Hello",
        "myVar2": "World"
    },
    "subValue": "$myVar1$ there"
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(variables=list(myVar1="Hello", myVar2="World"), subValue="$myVar1$ there"), 'data/myfile.json', auto_unbox = TRUE)
```

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
if (!is.null(inp$variables)) {
  for (v in names(inp$variables)) {
    var_name <- paste0("$", v, "$")
    var_value <- inp$variables[[v]]
    inp$subValue <- gsub(var_name, var_value, inp$subValue, fixed = TRUE)
  }
}
print(inp)
```

#### Extending to Multiple Replacements {#sec-variable-multiple}

The example in @sec-variable-simple demonstrated a simple case of variable parsing but how can this work in a more generalized approach when the JSON structure we wish to process is more complex.  One way to tackle this is to use `purrr::modify_tree()` which modifies the contents of a nested list.  An example if its use for variable parsing is shown below.

::: {.callout-tip}
`purrr::modify_tree(.x, .f)` recursively walks through a nested list `.x`, applying the function, `.f`, to every element in the tree, and returns a new list with the same structure.
:::

```json
{
    "variables": {
        "myVar1": "Hello",
        "myVar2": "World"
    },
    "contents": {
        "val1" : "$myVar1$ there",
        "val2" : "$myVar2$",
        "val3": {
            "val4": {
                "nested": "data",
                "nested_var": "$myVar1$ $myVar2$"
            },
            "val5": [
                "Regular text",
                "$myVar1$ $myVar2$"
            ]
        }
    }
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(variables=list(myVar1="Hello", myVar2="World"), contents=list(val1="$myVar1$ there", val2="$myVar2$", val3=list(val4=list(nested="data", nested_var="$myVar1$ $myVar2$"), val5=list("Regular text", "$myVar1$ $myVar2$")))), 'data/myfile.json', auto_unbox = TRUE)
```

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
contents <- inp$contents

for (v in names(inp$variables)) {
  var_name <- paste0("$", v, "$")
  var_value <- inp$variables[[v]]
  contents <- purrr::modify_tree(
    contents, 
    leaf = \(x) {
      if (is.list(x)) {
        x
      } else {
        gsub(var_name, var_value, x, fixed = TRUE)
      }
    }
  )
}

print(jsonlite::toJSON(contents, auto_unbox = TRUE, pretty = TRUE))
```

Let's unpack what's happening.  `contents` can be considered as a tree, containing both nodes (branches that contain other elements) and leaves (values that sit at the end of branches), such that:

```
contents                                    (node)
├─ val1 : "$myVar1$ there"                  (leaf)
├─ val2 : "$myVar2$"                        (leaf)
└─ val3                                     (node)
   ├─ val4                                  (node)
   │  ├─ nested      : "data"               (leaf)
   │  └─ nested_var  : "$myVar1$ $myVar2$"  (leaf)
   └─ val5                                  (node)
      ├─ [1] "Regular text"                 (leaf)
      └─ [2] "$myVar1$ $myVar2$"            (leaf)
```

We apply `purrr::modify_tree()` to `contents` in order to perform variable substitution within a deeply nested JSON structure.  The loop iterates over each entry in `inp$variables` and for each variable the following is performed:

1. the variable name is converted into a placeholder, eg `myVar1` becomes `$myVar1$`.
2. The corresponding replacement value is retrieved, eg `Hello`.
3. Within `modify_tree()`:
    - If the element is a list then it represents an internal node of the tree so simply return it unchanged.
    - If the element is not a list then it must be a leaf value, eg a string or numeric.  In this case `gsub` is used to replace any occurrence of the variable with its value.

This process is repeated for each variable, so that all placeholders, no matter how deeply nested, will be replaced with their corresponding values.  Once complete, `contents` holds the updated list with the original structure.

#### Extending to Different Types of Data

The concept of variables can be extended to account for different types of data.  The approach in @sec-variable-multiple works well for strings but fails in the cases of numeric, boolean and vectors.  To extend for numerics and booleans we cannot use `gsub()` and have to check for equivalence as shown in the example that follows:

```json
{
    "variables": {
        "myVar1": true,
        "myVar2": 55
    },
    "contents": {
        "val1" : "$myVar1$",
        "val2" : "$myVar2$"
    }
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(variables=list(myVar1=TRUE, myVar2=55), contents=list(val1="$myVar1$", val2="$myVar2$")), 'data/myfile.json', auto_unbox = TRUE)
```

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
contents <- inp$contents

for (v in names(inp$variables)) {
  var_name <- paste0("$", v, "$")
  var_value <- inp$variables[[v]]
  contents <- purrr::modify_tree(
    contents, 
    leaf = \(x) {
      if (is.list(x)) {
        x
      } else if (is.character(var_value)) {
        gsub(var_name, var_value, x, fixed = TRUE)
      } else if (identical(x, var_name)) {
        var_value
      } else {
        x
      }
    }
  )
}

print(jsonlite::toJSON(contents, auto_unbox = TRUE, pretty = TRUE))
```

The `modify_tree()` function now runs through the following checks:

-  If `x` is a list then return `x` (`x` is a node, not a leaf).
-  If `x` is a character vector then attempt to substitute the variable.
-  If `x` is not a character vector but is identical to a variable name, replace it with the variable value.
-  Otherwise return `x`.

This approach works when direct replacement is all that is required (eg replacing `$myVar2` with `55`).  It will not work when a variable is used in an expression (eg `$myVar2$ + 10`).

## Loops

### Loops in Pure JSON and YAML

Neither JSON or YAML support loops and therefore looping has to be built as a preprocessing layer in the engine.

### Looping Over Values

A simple looping strategy can be built into the engine as follows:

```json
{
    "loop": {
        "variable": "$l1$",
        "values": [1, 2, 3]
    },
    "content": {
        "val1": "$l1$",
        "val2": "Hello"
    }
}
```

and executed as follows:

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(loop=list(variable="$l1$", values=list(1,2,3)), content=list(val1="$l1$", val2="Hello")), 'data/myfile.json', auto_unbox = TRUE)
```

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)

result <- list()
if (!is.null(inp$loop)) {
  var_name <- inp$loop$variable
  for (l in inp$loop$values) {
    var_value <- l
    loop_result <- purrr::modify_tree(inp$content, leaf = \(x) {
      if (is.list(x)) {
        x
      } else {
        gsub(var_name, var_value, x, fixed = TRUE)
      }
    })
    result <- append(result, list(loop_result))
  }
}
print(result)
```

### Nested Loops

A more generic approach can be achieved by using `expand.grid()` to hold loop values.  Ann advantage of this approach is that nested loops can readily be constructed.  Take the example below with two loops:

```json
{
    "loop": [
        {
            "variable": "$loop1$", 
            "values": [1, 2, 3]
        },
        {
            "variable": "$loop2$", 
            "values": ["Alice", "Bob"]
        }
    ],        
    "content": {
        "val1": "$loop1$",
        "val2": "Hello $loop2$"
    }
}
```

Construction the engine using `expand.grid()` to build a data frame of all loop combinations and then running through them one by one is relatively simple:

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(loop=list(list(variable="$loop1$", values=list(1,2,3)), list(variable="$loop2$", values=list("Alice","Bob"))), content=list(val1="$loop1$", val2="Hello $loop2$")), 'data/myfile.json', auto_unbox = TRUE)
```

```{r}
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)

result <- list()

## list of all loop values and loop variable names
loops <- purrr::map(inp$loop, \(x) x$values) |>
    purrr::set_names(purrr::map_chr(inp$loop, \(x) x$variable))

## use expand.grid to build a data frame where each row contains a series of loop values
df_loops <- expand.grid(rev(loops), KEEP.OUT.ATTRS = FALSE)

## reconstruct a list with one entry for each series of loop values
l_loops <- split(df_loops, 1:nrow(df_loops))

for (loop_set in l_loops) {
  loop_updated <- inp$content
  for (loop_count in seq_along(loop_set)) {
    var_name <- names(loop_set)[loop_count]
    var_value <- loop_set[[loop_count]]

    loop_updated <- purrr::modify_tree(loop_updated, leaf = \(x) {
      if (is.list(x)) {
        x
      } else {
        gsub(var_name, var_value, x, fixed = TRUE)
      }
    })
  }
  result <- append(result, list(loop_updated))
}

print(result)
```

The data frame `df_loops` looks as follows:

```{r}
df_loops
```
