# Introduction

Once imported, one or more data wrangling steps are often required to manipulate data into its required form and format.  This chapter illustrates how data wrangling can be performed using a instruction set using the {dplyr} library.  Of course, other approaches, such as using base R functions and {data.table} may also be applied and the concepts presented here will hold true.

## Non-Standard Evaluation

In base R, most functions use standard evaluation, i.e. arguments are evaluated before the function is called.  For example when evaluating `mean(x)`, `x` is evaluated immediately and passed to the `mean()` function.

Many **tidyverse** verbs behave differently.  In functions such as `dplyr::filter()` and `dplyr::mutate()`, expressions are captured first and evaluated later, known as **non-standard evaluation (NSE)**.  For example in `dplyr::filter(mtcars, mpg > 30)` **mpg > 30** is not evaluated immediately.  Instead it is captured as an expression and evaluated later.  This delayed evaluation allows the column name, **mpg** to be written as if it were a variable.

## Tidy Evaluation

Non-standard evaluation works well for interactive use but creates challenges when working programatically.  Tidy evaluation allows us to capture expressions and manipulate them as data.  In tidy evaluation we can create a symbol, which is something that is looked up at evaluation time, using the `rlang::sym()` function.  For example, considering the three code blocks below:

```{r, filename="non-standard evaluation"}
## non-standard evaluation
## this code works
dplyr::filter(mtcars, mpg > 30)
```

```{r, filename="variables: fail"}
#| error: false
## this code fails
col <- "mpg"
value <- 30
dplyr::filter(mtcars, col > value)
```

```{r, filename="variables: success"}
## this code works
col <- "mpg"
expr <- rlang::sym(col)
value <- 30
dplyr::filter(mtcars, !!expr > value)
```

The first example works because it is the simplest case of non-standard evaluation and is well suited for interactive use.  
The second example attempts to run the same code using variables.  This fails because **col** in the expression **col > value** is treated as the literal variable name rather than being resolved to the column name **mpg**.  
In the third example, we construct an expression, `expr` from the *symbol* corresponding to **col**.  We then use the `!!` operator to inject that symbol into `dplyr::filter()`.  Since `rlang::sym(col)` produces the symbol **mpg**, the expression  
`dplyr::filter(mtcars, !!expr > value)`  
is equivalent to  
`dplyr::filter(mtcars, mpg > value)`.

While `!!` allows a single symbol or expression to be injected into a tidy-evaluated call, there are times where we wish to inject multiple expressions at once.  The `!!!` operator is used to splice a list of expressions into a function call.  This can be particularly useful when building a list of `dplyr::filter()` or `dplyr::arrange()` conditions.

## Command Parsing {#sec-command-parsing}

The simplest approach is to specify the data manipulation step and execute it by evaluating it as an expression.  The base R functions `eval` and `parse` or the {rlang} function `parse_expr` can be used for this purpose.  There are two cases illustrated below.  The first parses raw R code directly and the second parses a dplyr::filter() step.

### Parsing of R Code

In the example code below we define a `data_processing` step and evaluate it by parsing.

```json
{
  "data_processing": "dplyr::filter(mtcars, mpg > 30)"
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(data_processing="dplyr::filter(mtcars, mpg > 30)"), 'data/myfile.json', auto_unbox = TRUE)
```

```{r filename="base R eval and parse"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- eval(parse(text = inp$data_processing))
print(data)
```

```{r filename="rlang parse_expr"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- rlang::eval_tidy(rlang::parse_expr(inp$data_processing))
print(data)
```

### Parsing a dplyr::filter() Step

In the example code below we define `filter_process`, a filter, as `mpg > 30` and evaluate it within a `dplyr::filter()` function.

```json
{
  "filter_process": "mpg > 30"
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(filter_process="mpg > 30"), 'data/myfile.json', auto_unbox = TRUE)
```

```{r filename="base R eval and parse"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- dplyr::filter(mtcars, eval(parse(text = inp$filter_process)))
print(data)
```

```{r filename="rlang parse_expr"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- dplyr::filter(mtcars, !!rlang::parse_expr(inp$filter_process))
print(data)
```

Note that when using the dplyr::filter() function we can take advantage of the `!!` operator and use injection to evaluate it.

:::{.callout-warning}
## Important
Such approaches are simplistic to build but open to abuse.  Parsing raw commands through an engine can often lead to undesired effects and should be avoided where possible.  An alternative approach is to break down the data wrangling steps.
:::
