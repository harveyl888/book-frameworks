# Introduction

Once imported, one or more data wrangling steps are often required to manipulate data into its required form and format.  This section illustrates how data wrangling can be performed using a instruction set using the {dplyr} and {tidyr} libraries.  Of course, other approaches, such as using base R functions and {data.table} may also be applied and the concepts presented here will hold true.

## Non-Standard Evaluation

In base R, most functions use standard evaluation, i.e. arguments are evaluated before the function is called.  For example when evaluating `mean(x)`, `x` is evaluated immediately and passed to the `mean()` function.

Many **tidyverse** verbs behave differently.  In functions such as `dplyr::filter()` and `dplyr::mutate()`, expressions are first captured and evaluated later, a process known as **non-standard evaluation (NSE)**.  For example in `dplyr::filter(mtcars, mpg > 30)`, the expression **mpg > 30** is not evaluated at the time the function is called.  Instead it is captured and evaluated later.  This delayed evaluation allows column names, such as **mpg**, to be written as though they were ordinary variables.

## Tidy Evaluation

Non-standard evaluation works well for interactive use but creates challenges when working programatically.  Tidy evaluation addresses this by allowing expressions to be captured and manipulated as data.  One of the key building blocks of tidy evaluation is the *symbol*, which represents a name which is looked up when the expression is evaluated, rather than when it is created.  Symbols can be constructed programmatically using `rlang::sym()`.  For example, consider the three code blocks below:

```{r, filename="non-standard evaluation"}
## non-standard evaluation
## this code works
dplyr::filter(mtcars, mpg > 30)
```

```{r, filename="variables: fail"}
#| error: false
## this code fails
col <- "mpg"
value <- 30
dplyr::filter(mtcars, col > value)
```

```{r, filename="variables: success"}
## this code works
col <- "mpg"
expr <- rlang::sym(col)
value <- 30
dplyr::filter(mtcars, !!expr > value)
```

The first example works because it is the simplest case of non-standard evaluation and is well suited for interactive use.  
The second example attempts to run the same code using variables.  This fails because **col** in the expression **col > value** is treated as the literal variable name rather than being resolved to the column name **mpg**.  
In the third example, we construct an expression, `expr` from the *symbol* corresponding to **col**.  We then use the `!!` operator to inject that symbol into `dplyr::filter()`.  Since `rlang::sym(col)` produces the symbol **mpg**, the expression  
`dplyr::filter(mtcars, !!expr > value)`  
is equivalent to  
`dplyr::filter(mtcars, mpg > value)`.

While `!!` allows a single symbol or expression to be injected into a tidy-evaluated call, there are times where we wish to inject multiple expressions at once.  The `!!!` operator is used to splice a list of expressions into a function call.  This can be particularly useful when building a list of `dplyr::filter()` or `dplyr::arrange()` conditions.

## Command Parsing {#sec-command-parsing}

The simplest approach is to specify a data manipulation step and execute it by evaluating it as an expression.  The base R functions `eval` and `parse` or the {rlang} function `parse_expr` can be used for this purpose.  In the example code below we define `filter_process`, a filter, as `mpg > 30` and evaluate it within a `dplyr::filter()` function.

```json
{
  "filter_process": "mpg > 30"
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(filter_process="mpg > 30"), 'data/myfile.json', auto_unbox = TRUE)
```

```{r filename="base R eval and parse"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- dplyr::filter(mtcars, eval(parse(text = inp$filter_process)))
print(data)
```

```{r filename="rlang parse_expr"}
#| message: false
inp <- jsonlite::fromJSON("data/myfile.json", simplifyVector = FALSE)
data <- dplyr::filter(mtcars, !!rlang::parse_expr(inp$filter_process))
print(data)
```

:::{.callout-important}
## Important
Such approaches are simplistic to build but open to abuse.  Parsing raw commands through an engine can often lead to undesired effects and should be avoided where possible.  An alternative approach is to break down the data wrangling steps.
:::

The following chapters will demonstrate how data wrangling steps can be broken down and reconstructed so that `eval(parse())` is not necessary.
