# The Instruction Set

The instruction set tells the engine what to do.  Once read, the engine then parses the instructions and responds accordingly.  The instruction set should be written in a human-readable form and be editable by hand or programmatically.  Two common formats that can be used for building instruction sets are JSON and YAML.

## The JSON Format

JSON (Javascript Object Notation) is a lightweight, language-independent, human-readable format for transferring data.  Several R libraries are available to import and convert between JSON and R list format (for the purpose of this book we will use {jsonlite} to convert between formats).

JSON objects are made up of key-value pairs separated by a colon surrounded by curly braces.  An example of a json object is shown below:

```json
{
  "name": "Joe Bloggs",
  "age": 25,
  "family_member": true
}
```

In the case above we have three key-value pairs separated by commas.  The first (*name*) returns a string, the second (*age*) returns a numeric and the third (*family_member*) returns a boolean.

JSON objects may be nested, creating a hierarchy as follows:

```json
{
  "name": "Joe Bloggs",
  "age": 25,
  "family_member": true,
  "pets": {
    "has_pets": true,
    "number_pets": 3
  }
}
```

JSON also accepts arrays, enclosed in square braces:

```json
{
  "name": "Joe Bloggs",
  "age": 25,
  "family_member": true,
  "pets": {
    "has_pets": true,
    "number_pets": 3,
    "pet_types": ["dog", "dog", "cat"]
  }
}
```

### Using the {jsonlite} R Package

{jsonlite} can quickly convert between JSON and R data types.  Generally, when using JSON as an instruction format for frameworks, we will be converting the JSON format into an R list.  A list provides several benefits when we wish to parse data through an engine.  

-  A list can contain heterogeneous data types, hence the instruction set can built from different data types, such as strings, numbers and booleans.
-  An item missing from a list will return `NULL` so it is easy to check for existence of a parameter in the engine.

To convert the json string above to a list, simply use `jsonlite::fromJSON()` as follows:

```{r}
json_string <- '
{
  "name": "Joe Bloggs",
  "age": 25,
  "family_member": true,
  "pets": {
    "has_pets": true,
    "number_pets": 3,
    "pet_types": ["dog", "dog", "cat"]
  }
}
'
jsonlite::fromJSON(json_string, simplifyVector = FALSE)
```

The argument `simplifyVector =  TRUE` is included to stop simplification in which the JSON string could be converted into a more specific data type.  

## The YAML Format

Similar to JSON, YAML (YAML Ain't Markup Language) is a lightweight, language-independent, human-readable format for transferring data.  It primarily differs from JSON by using indentation as opposed to brackets to denote shape and function.  

YAML objects are made up of key-value pairs separated by a colon.  Unlike JSON, No braces are required and strings do not have to be quoted, unless special characters are included.  An example of a YAML object is shown below:

```yaml
name: Joe Bloggs
age: 25
family_member: true
```

This is very similar to the JSON example above, key-value pairs.  The first (*name*) returns a string, the second (*age*) returns a numeric and the third (*family_member*) returns a boolean.

Indentation provides structure to YAML data.  The specific number of spaces used to indent is not important as long as parallel elements have the same indentation.  Subsequent indentations define the data structure further.

```yaml
name: Joe Bloggs
age: 25
family_member: true
pets:
  has_pets: true
  number_pets: 3
```

Arrays can be specified using a hyphen and space as folows:

```yaml
name: Joe Bloggs
age: 25
family_member: true
pets:
  has_pets: true
  number_pets: 3
  pet_types:
    - dog
    - dog
    - cat
```

### Using the {yaml} R Package

{yaml} can read in and convert a YAML file to an R list.  To convert the YAML above to a list use `yaml::yaml.load()` as folllows:

```{r}
yaml_string <- "
name: Joe Bloggs
age: 25
family_member: true
pets:
  has_pets: true
  number_pets: 3
  pet_types:
    - dog
    - dog
    - cat
"
yaml::yaml.load(yaml_string)
```

### Working with Booleans

Care should be taken with YAML as several values may be interpreted as boolean `true` and `false`.  In YAML 1.1 all of the following will be interpreted as `true`:  
y, Y, yes, Yes, YES, true, True, TRUE, on, On, ON  
and all of the following will be interpreted as `false`:
n, N, no, No, NO, false, False, FALSE, off, Off, OFF  
When using YAML 1.2 the only boolean values allowed are `true` and `false`.  The {yaml} package, however, implements the `libyaml` parser which is based on YAML 1.1.  Therefore the following will all return `true`

```yaml
val1: true
val2: on
val3: Y
```

```{r}
#| echo: false
tmp_yaml <- "
val1: true
val2: on
val3: Y
"
yaml::yaml.load(tmp_yaml)
```

If strings are required instead of booleans, values should be quoted:

```yaml
val1: true
val2: 'on'
val3: "Y"
```

```{r}
#| echo: false
tmp_yaml <- "
val1: true
val2: 'on'
val3: \"Y\"
"
yaml::yaml.load(tmp_yaml)
```

## Differences Between JSON and YAML

-  Format - JSON uses braces, brackets and quotes, YAML uses indentation and no quotes.
-  Comments - JSON does not support comments whereas YAML does.
-  Data Types - JSON can handle strings, numbers, objects, arrays, booleans and nulls.  YAML can handle some additional types

YAML is a superset of JSON.  Any valid JSON is also valid YAML.  Either can be used but when should you use each?  JSON is stricter and simpler than YAML, whereas YAML is more human-readable.  JSON is commonly used in machine-to-machine communication, whereas YAML has been adopted more when written by a human.

:::{.callout-note}
This book will use JSON format from this point forward but, please note, YAML could be substituted in its place.
:::

## Coding Instructions

Our instruction set is designed to be both human-readable and computer interpretable.  With this in mind we can make some specific choices as to how an instruction set should be composed.  For example, importing a dataset could be as simple as the following:

```json
{
  "import_file": "myfile.txt"
}
```

It is the job of the engine to take this instruction, understand that we wish to import a file called `myfile.txt` and perform the correct commands to achieve the task.  Clearly we can get more complex with our instructions.  Consider importing a dataset and building a plot.   Here we could consider an instruction set that looks like:

```json
{
  "file": {
    "filename": "myfile.txt"
  },
  "plot": {
    "type": "scatter",
    "x": "x_data",
    "y": "y_data"
  }
}
```

Here we specify a file, `myfile.txt`, and a scatterplot where `x_data` are plotted against `y_data`.  Once again, it is the job of the engine to understand that it needs to import and plot the data.  We could also craft two engines - one to import the data and one to build a plot.

This approach is fine and it can be useful when you wish to change a parameter but not touch the code.  The real benefit, however, can be seen when the number of records is increased.  For example, the instruction set below uses a JSON array to hold two individual instruction sets, each identified by a reference number, `ref`:

```json
[
  {
    "ref": 1,
    "file": {
      "filename": "myfile1.txt"
    },
    "plot": {
      "type": "scatter",
      "x": "x_data",
      "y": "y_data"
    }
  },
  {
    "ref": 2,
    "file": {
      "filename": "myfile2.txt"
    },
    "plot": {
      "type": "scatter",
      "x": "days",
      "y": "counts"
    }
  }
]
```

Reading this instruction set in R produces the following list:
```{r}
j <- '
[
  {
    "ref": 1,
    "file": {
      "filename": "myfile1.txt"
    },
    "plot": {
      "type": "scatter",
      "x": "x_data",
      "y": "y_data"
    }
  },
  {
    "ref": 2,
    "file": {
      "filename": "myfile2.txt"
    },
    "plot": {
      "type": "scatter",
      "x": "days",
      "y": "counts"
    }
  }
]'
l_instructions <- jsonlite::fromJSON(j, simplifyVector = FALSE)
print(l_instructions)
```

and individual records can be easily accessed using {purrr}

```{r}
l_instructions |> purrr::keep(\(x) x[["ref"]] == 2)
```
