# Automating Shiny Reactivity

A minimal amount of shiny reactivity can be introduced in an automated fashion.  For extensive shiny reactivity the author is encouraged to consider shiny modules, covered in a later chapter.

## Adding Reactivity - Multiple observeEvents

In this example, we'll build a series of actionButtons and assign a shiny observe/bindEvent function to each.  The observe function responds to a button press, updating a reactiveValue.  It's important to note that in the code below we generate five observe functions programatically.

```{r}
#| eval: false
server <- function(input, output, session) {
  
  rv <- reactiveValues(
    click = ""
  )
  
  output$uiout <- renderUI({
    lapply(seq(5), function(i) {
      observe({
        rv$click <- paste0("Button ", i, " clicked")
      }) |>
        bindEvent(input[[paste0("but_", i)]], ignoreInit = TRUE)
    })
    
    tagList(
      lapply(seq(5), function(i) {
        actionButton(inputId = paste0("but_", i), label = paste0("Button ", i))
      })
    )
  })
  
  output$txt <- renderPrint(
    print(rv$click)
  )
  
}

ui <- fluidPage(
  uiOutput('uiout')
  verbatimTextOutput("txt")
)

shinyApp(ui, server)
```

The resulting app contains five actionButtons, each linked to an observeEvent.

![](images/shiny_reactivity_01.png)

The reactive graph illustrates the five observeEvent functions created programatically.

![](images/shiny_reactivity_02.png)

Although effective, this is not a very efficient way of programming.  The next section will ilustrate how to achieve the same effect with a single observe/bindEvent function.

## Adding Reactivity - Single observeEvent

In this example, we'll build the same series of actionButtons but this time assign a single shiny observe function to all of them.  As before, the observe/bindEvent responds to a button press, updating a reactiveValue.  Here we use the `Shiny.setInputValue` javascript function to set the value of a shiny input variable.  The addition of `{priority: "event"}` will ensure that the shiny variable is updated on every button click, even if the same button is clicked two times in succession.

```{r}
#| eval: false
server <- function(input, output, session) {
  
  rv <- reactiveValues(
    click = ""
  )
  
  output$uiout <- renderUI({
    
    observe({
      rv$click <- paste0("Button ", input$button_click, " clicked")
    }) |>
      bindEvent(input$button_click, ignoreInit = TRUE)
    
    tagList(
      lapply(seq(5), function(i) {
        actionButton(inputId = paste0("but_", i),
                     label = paste0("Button ", i),
                     onclick=paste0('Shiny.setInputValue("button_click", ', i, ', {priority: "event"})'))
      })
    )
  })
  
  output$txt <- renderPrint(
    print(rv$click)
  )
  
}

ui <- fluidPage(
  uiOutput('uiout')
  verbatimTextOutput("txt")
)

shinyApp(ui, server)
```

The resulting app contains five actionButtons, each linked to an observeEvent.

![](images/shiny_reactivity_03.png)

The reactive graph illustrates the simpler reactivity.

![](images/shiny_reactivity_04.png)

Here, it should be noted, that we have added an onclick event to each actionButton to trigger an observeEvent.  When an actionButton is clicked the shiny reactive `input$button_click` is updated to the index of the button. 

## Applied Using an Instruction set

We can build the reactivity shown above with an instruction set in more than one way.  The simplest approach assumes that all functionality is already included in the code.  For example, following on from the example in @sec-interface-assignment-widgets, which uses the `survivalists.csv` Alone data set from Tidy Tuesday: 

```json
{
  "dataset": "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv",
  "columns": ["season", "age", "gender", "country", "medically_evacuated", "profession"],
  "build_widgets": true,
  "widget_reactivtiy": ["season", "age"]
}
```

```{r}
#| echo: false
#| eval: true
jsonlite::write_json(list(dataset="https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv", columns=list("season", "age", "gender", "country", "medically_evacuated", "profession"), build_widgets=TRUE, widget_reactivity=list("season", "age")), 'data/myfile.json', auto_unbox = TRUE)
```


The interpreter could look something like:

```{r}
#| message: false
#| warning: false
#| eval: false
inp <- list(dataset="https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-24/survivalists.csv", columns=list("season", "age", "gender", "country", "medically_evacuated", "profession"), build_widgets=TRUE, widget_reactivity=list("season", "age"))

only_cols <- unlist(inp$columns)
data <- readr::read_csv(inp$dataset, col_select = only_cols)

library(shiny)

server <- function(input, output, session) {
  
  output$uiout <- renderUI({
    
    shiny_out <- lapply(seq(ncol(data)), function(i) {
      col_class <- sapply(data, class)[i]
      if (col_class == "logical") {
        ## checkbox
        checkboxInput(inputId = sprintf("Control_%02i", i), 
                      label = names(data)[i])
      } else if (col_class == "numeric") {
        ## numericInput
        if (length(unique(data[[i]])) > 10) {
          sliderInput(inputId = sprintf("Control_%02i", i),
                      label = names(data)[i],
                      min = min(data[[i]]),
                      max = max(data[[i]]),
                      value = min(data[[i]]))
        } else {
          numericInput(inputId = sprintf("Control_%02i", i), 
                       label = names(data)[i],
                       min = min(data[[i]]),
                       max = max(data[[i]]),
                       value = min(data[[i]]))
        }
      } else if (col_class == "character") {
        n_values <- length(unique(data[[i]]))
        if (n_values <= 3) {
          ## radiobuttons
          radioButtons(inputId = sprintf("Control_%02i", i),
                       label = names(data)[i],
                       inline = TRUE,
                       choices = sort(unique(data[[i]])))
        } else {
          ## selectizeInput
          selectizeInput(inputId = sprintf("Control_%02i", i),
                         label = names(data)[i],
                         choices = sort(unique(data[[i]])))
        }
      } 
    })
    tagList(shiny_out)
  })
}

ui <- fluidPage(
  uiOutput('uiout')
)

shinyApp(ui, server)

```
